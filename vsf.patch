 lib/curl_memory.h             |  17 ++++
 lib/curl_setup.h              |   4 +
 lib/easy.c                    |  46 ++++++++++
 lib/rand.c                    |  20 +++++
 lib/version.c                 | 191 ++++++++++++++++++++++++++++++++++++++++++
 lib/vtls/keylog.c             |  12 +++
 lib/vtls/mbedtls.c            |  14 ++++
 lib/vtls/mbedtls_threadlock.c |  12 +++
 lib/vtls/vtls.c               |  28 +++++++
 src/tool_cb_dbg.c             |  31 +++++++
 src/tool_convert.c            |  20 +++++
 src/tool_getpass.c            |  32 +++++++
 src/tool_operate.c            |  19 +++++
 src/tool_operate.h            |  14 ++++
 src/tool_paramhlp.c           |  17 ++++
 src/tool_progress.c           |  29 ++++++-
 src/tool_progress.h           |  28 +++++++
 17 files changed, 531 insertions(+), 3 deletions(-)

diff --git a/lib/curl_memory.h b/lib/curl_memory.h
index 580629063..01c1d9c69 100644
--- a/lib/curl_memory.h
+++ b/lib/curl_memory.h
@@ -98,11 +98,28 @@ typedef void *(*curl_calloc_callback)(size_t nmemb, size_t size);
 #define CURL_DID_MEMORY_FUNC_TYPEDEFS
 #endif
 
+#ifdef __VSF__
+struct __curl_memory_ctx {
+    curl_malloc_callback Curl_cmalloc;
+    curl_free_callback Curl_cfree;
+    curl_realloc_callback Curl_crealloc;
+    curl_strdup_callback Curl_cstrdup;
+    curl_calloc_callback Curl_ccalloc;
+};
+declare_vsf_curl_mod(curl_memory)
+#   define curl_memory_ctx          ((struct __curl_memory_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_memory)))
+#   define Curl_cmalloc             (curl_memory_ctx->Curl_cmalloc)
+#   define Curl_cfree               (curl_memory_ctx->Curl_cfree)
+#   define Curl_crealloc            (curl_memory_ctx->Curl_crealloc)
+#   define Curl_cstrdup             (curl_memory_ctx->Curl_cstrdup)
+#   define Curl_ccalloc             (curl_memory_ctx->Curl_ccalloc)
+#else
 extern curl_malloc_callback Curl_cmalloc;
 extern curl_free_callback Curl_cfree;
 extern curl_realloc_callback Curl_crealloc;
 extern curl_strdup_callback Curl_cstrdup;
 extern curl_calloc_callback Curl_ccalloc;
+#endif
 #if defined(WIN32) && defined(UNICODE)
 extern curl_wcsdup_callback Curl_cwcsdup;
 #endif
diff --git a/lib/curl_setup.h b/lib/curl_setup.h
index 61384cdff..05971206f 100644
--- a/lib/curl_setup.h
+++ b/lib/curl_setup.h
@@ -26,6 +26,10 @@
 #define CURL_NO_OLDIES
 #endif
 
+#ifdef __VSF__
+#   include "config_vsf.h"
+#endif
+
 /*
  * Disable Visual Studio warnings:
  * 4127 "conditional expression is constant"
diff --git a/lib/easy.c b/lib/easy.c
index 20293a710..5e2061da0 100644
--- a/lib/easy.c
+++ b/lib/easy.c
@@ -87,8 +87,40 @@
 #include "memdebug.h"
 
 /* true globals -- for curl_global_init() and curl_global_cleanup() */
+#ifdef __VSF__
+void __curl_memory_init(void *ctx)
+{
+#if VSF_LINUX_LIBC_CFG_WRAPPER == ENABLED
+  Curl_cmalloc = (curl_malloc_callback)VSF_LINUX_LIBC_WRAPPER(malloc);
+  Curl_cfree = (curl_free_callback)VSF_LINUX_LIBC_WRAPPER(free);
+  Curl_crealloc = (curl_realloc_callback)VSF_LINUX_LIBC_WRAPPER(realloc);
+  Curl_cstrdup = (curl_strdup_callback)VSF_LINUX_LIBC_WRAPPER(strdup);
+  Curl_ccalloc = (curl_calloc_callback)VSF_LINUX_LIBC_WRAPPER(calloc);
+#else
+  Curl_cmalloc = (curl_malloc_callback)malloc;
+  Curl_cfree = (curl_free_callback)free;
+  Curl_crealloc = (curl_realloc_callback)realloc;
+  Curl_cstrdup = (curl_strdup_callback)strdup;
+  Curl_ccalloc = (curl_calloc_callback)calloc;
+#endif
+}
+define_vsf_curl_mod(curl_memory, sizeof(struct __curl_memory_ctx), VSF_CURL_MOD_MEMORY, __curl_memory_init)
+
+struct __curl_easy_ctx {
+    unsigned int initialized;
+    long init_flags;
+#ifdef DEBUGBUILD
+    char *leakpointer;
+#endif
+};
+define_vsf_curl_mod(curl_easy, sizeof(struct __curl_easy_ctx), VSF_CURL_MOD_EASY, NULL)
+#   define curl_easy_ctx            ((struct __curl_easy_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_easy)))
+#   define initialized              (curl_easy_ctx->initialized)
+#   define init_flags               (curl_easy_ctx->init_flags)
+#else
 static unsigned int  initialized;
 static long          init_flags;
+#endif
 
 /*
  * strdup (and other memory functions) is redefined in complicated
@@ -111,11 +143,13 @@ static long          init_flags;
  * If a memory-using function (like curl_getenv) is used before
  * curl_global_init() is called, we need to have these pointers set already.
  */
+#ifndef __VSF__
 curl_malloc_callback Curl_cmalloc = (curl_malloc_callback)malloc;
 curl_free_callback Curl_cfree = (curl_free_callback)free;
 curl_realloc_callback Curl_crealloc = (curl_realloc_callback)realloc;
 curl_strdup_callback Curl_cstrdup = (curl_strdup_callback)system_strdup;
 curl_calloc_callback Curl_ccalloc = (curl_calloc_callback)calloc;
+#endif
 #if defined(WIN32) && defined(UNICODE)
 curl_wcsdup_callback Curl_cwcsdup = Curl_wcsdup;
 #endif
@@ -125,8 +159,12 @@ curl_wcsdup_callback Curl_cwcsdup = Curl_wcsdup;
 #endif
 
 #ifdef DEBUGBUILD
+#ifdef __VSF__
+#   define leakpointer              (curl_easy_ctx->leakpointer)
+#else
 static char *leakpointer;
 #endif
+#endif
 
 /**
  * curl_global_init() globally initializes curl given a bitwise set of the
@@ -139,11 +177,19 @@ static CURLcode global_init(long flags, bool memoryfuncs)
 
   if(memoryfuncs) {
     /* Setup the default memory functions here (again) */
+#if defined(__VSF__) && VSF_LINUX_LIBC_CFG_WRAPPER == ENABLED
+    Curl_cmalloc = (curl_malloc_callback)VSF_LINUX_LIBC_WRAPPER(malloc);
+    Curl_cfree = (curl_free_callback)VSF_LINUX_LIBC_WRAPPER(free);
+    Curl_crealloc = (curl_realloc_callback)VSF_LINUX_LIBC_WRAPPER(realloc);
+    Curl_cstrdup = (curl_strdup_callback)VSF_LINUX_LIBC_WRAPPER(strdup);
+    Curl_ccalloc = (curl_calloc_callback)VSF_LINUX_LIBC_WRAPPER(calloc);
+#else
     Curl_cmalloc = (curl_malloc_callback)malloc;
     Curl_cfree = (curl_free_callback)free;
     Curl_crealloc = (curl_realloc_callback)realloc;
     Curl_cstrdup = (curl_strdup_callback)system_strdup;
     Curl_ccalloc = (curl_calloc_callback)calloc;
+#endif
 #if defined(WIN32) && defined(UNICODE)
     Curl_cwcsdup = (curl_wcsdup_callback)_wcsdup;
 #endif
diff --git a/lib/rand.c b/lib/rand.c
index 8f2c1ba29..25f4cbce8 100644
--- a/lib/rand.c
+++ b/lib/rand.c
@@ -36,12 +36,28 @@
 #include "curl_memory.h"
 #include "memdebug.h"
 
+#ifdef __VSF__
+struct __curl_rand_ctx {
+    struct {
+        unsigned int randseed;
+        bool seeded;
+    } randit;
+};
+define_vsf_curl_mod(curl_rand, sizeof(struct __curl_rand_ctx), VSF_CURL_MOD_RAND, NULL)
+#   define curl_rand_ctx            ((struct __curl_rand_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_rand)))
+#endif
+
 static CURLcode randit(struct Curl_easy *data, unsigned int *rnd)
 {
   unsigned int r;
   CURLcode result = CURLE_OK;
+#ifdef __VSF__
+#   define randseed                 (curl_rand_ctx->randit.randseed)
+#   define seeded                   (curl_rand_ctx->randit.seeded)
+#else
   static unsigned int randseed;
   static bool seeded = FALSE;
+#endif
 
 #ifdef CURLDEBUG
   char *force_entropy = getenv("CURL_ENTROPY");
@@ -99,6 +115,10 @@ static CURLcode randit(struct Curl_easy *data, unsigned int *rnd)
   r = randseed = randseed * 1103515245 + 12345;
   *rnd = (r << 16) | ((r >> 16) & 0xFFFF);
   return CURLE_OK;
+#ifdef __VSF__
+#   undef randseed
+#   undef seeded
+#endif
 }
 
 /*
diff --git a/lib/version.c b/lib/version.c
index c84ef85fb..155a7dd88 100644
--- a/lib/version.c
+++ b/lib/version.c
@@ -74,6 +74,156 @@
 #include <ldap.h>
 #endif
 
+#ifdef __VSF__
+struct __curl_version_ctx {
+    curl_version_info_data version_info;
+    struct {
+        char out[300];
+    } curl_version;
+    struct {
+#if defined(USE_SSH)
+        char ssh_buffer[80];
+#endif
+#ifdef USE_SSL
+#ifdef CURL_WITH_MULTI_SSL
+        char ssl_buffer[200];
+#else
+        char ssl_buffer[80];
+#endif
+#endif
+#ifdef HAVE_BROTLI
+        char brotli_buffer[80];
+#endif
+#ifdef HAVE_ZSTD
+        char zstd_buffer[80];
+#endif
+    } curl_version_info;
+};
+static const char * const protocols[];
+static void __curl_version_mod_init(void *ctx)
+{
+    struct __curl_version_ctx *__curl_version_ctx = ctx;
+    __curl_version_ctx->version_info = (curl_version_info_data) {
+  CURLVERSION_NOW,
+  LIBCURL_VERSION,
+  LIBCURL_VERSION_NUM,
+  OS, /* as found by configure or set by hand at build-time */
+  0 /* features is 0 by default */
+#ifdef ENABLE_IPV6
+  | CURL_VERSION_IPV6
+#endif
+#ifdef USE_SSL
+  | CURL_VERSION_SSL
+#endif
+#ifdef USE_NTLM
+  | CURL_VERSION_NTLM
+#endif
+#if !defined(CURL_DISABLE_HTTP) && defined(USE_NTLM) && \
+  defined(NTLM_WB_ENABLED)
+  | CURL_VERSION_NTLM_WB
+#endif
+#ifdef USE_SPNEGO
+  | CURL_VERSION_SPNEGO
+#endif
+#ifdef USE_KERBEROS5
+  | CURL_VERSION_KERBEROS5
+#endif
+#ifdef HAVE_GSSAPI
+  | CURL_VERSION_GSSAPI
+#endif
+#ifdef USE_WINDOWS_SSPI
+  | CURL_VERSION_SSPI
+#endif
+#ifdef HAVE_LIBZ
+  | CURL_VERSION_LIBZ
+#endif
+#ifdef DEBUGBUILD
+  | CURL_VERSION_DEBUG
+#endif
+#ifdef CURLDEBUG
+  | CURL_VERSION_CURLDEBUG
+#endif
+#ifdef CURLRES_ASYNCH
+  | CURL_VERSION_ASYNCHDNS
+#endif
+#if (SIZEOF_CURL_OFF_T > 4) && \
+    ( (SIZEOF_OFF_T > 4) || defined(USE_WIN32_LARGE_FILES) )
+  | CURL_VERSION_LARGEFILE
+#endif
+#if defined(WIN32) && defined(UNICODE) && defined(_UNICODE)
+  | CURL_VERSION_UNICODE
+#endif
+#if defined(CURL_DOES_CONVERSIONS)
+  | CURL_VERSION_CONV
+#endif
+#if defined(USE_TLS_SRP)
+  | CURL_VERSION_TLSAUTH_SRP
+#endif
+#if defined(USE_NGHTTP2) || defined(USE_HYPER)
+  | CURL_VERSION_HTTP2
+#endif
+#if defined(ENABLE_QUIC)
+  | CURL_VERSION_HTTP3
+#endif
+#if defined(USE_UNIX_SOCKETS)
+  | CURL_VERSION_UNIX_SOCKETS
+#endif
+#if defined(USE_LIBPSL)
+  | CURL_VERSION_PSL
+#endif
+#if defined(CURL_WITH_MULTI_SSL)
+  | CURL_VERSION_MULTI_SSL
+#endif
+#if defined(HAVE_BROTLI)
+  | CURL_VERSION_BROTLI
+#endif
+#if defined(HAVE_ZSTD)
+  | CURL_VERSION_ZSTD
+#endif
+#ifndef CURL_DISABLE_ALTSVC
+  | CURL_VERSION_ALTSVC
+#endif
+#ifndef CURL_DISABLE_HSTS
+  | CURL_VERSION_HSTS
+#endif
+#if defined(USE_GSASL)
+  | CURL_VERSION_GSASL
+#endif
+  ,
+  NULL, /* ssl_version */
+  0,    /* ssl_version_num, this is kept at zero */
+  NULL, /* zlib_version */
+  protocols,
+  NULL, /* c-ares version */
+  0,    /* c-ares version numerical */
+  NULL, /* libidn version */
+  0,    /* iconv version */
+  NULL, /* ssh lib version */
+  0,    /* brotli_ver_num */
+  NULL, /* brotli version */
+  0,    /* nghttp2 version number */
+  NULL, /* nghttp2 version string */
+  NULL, /* quic library string */
+#ifdef CURL_CA_BUNDLE
+  CURL_CA_BUNDLE, /* cainfo */
+#else
+  NULL,
+#endif
+#ifdef CURL_CA_PATH
+  CURL_CA_PATH,  /* capath */
+#else
+  NULL,
+#endif
+  0,    /* zstd_ver_num */
+  NULL, /* zstd version */
+  NULL, /* Hyper version */
+  NULL  /* gsasl version */
+};
+}
+define_vsf_curl_mod(curl_version, sizeof(struct __curl_version_ctx), VSF_CURL_MOD_VERSION, __curl_version_mod_init)
+#   define curl_version_ctx     ((struct __curl_version_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_version)))
+#endif
+
 #ifdef HAVE_BROTLI
 static void brotli_version(char *buf, size_t bufsz)
 {
@@ -110,7 +260,11 @@ static void zstd_version(char *buf, size_t bufsz)
 
 char *curl_version(void)
 {
+#ifdef __VSF__
+#   define out                      (curl_version_ctx->curl_version.out)
+#else
   static char out[300];
+#endif
   char *outp;
   size_t outlen;
   const char *src[VERSION_PARTS];
@@ -292,6 +446,9 @@ char *curl_version(void)
   *outp = 0;
 
   return out;
+#ifdef __VSF__
+#   undef out
+#endif
 }
 
 /* data for curl_version_info
@@ -383,6 +540,9 @@ static const char * const protocols[] = {
   NULL
 };
 
+#ifdef __VSF__
+#   define version_info             (curl_version_ctx->version_info)
+#else
 static curl_version_info_data version_info = {
   CURLVERSION_NOW,
   LIBCURL_VERSION,
@@ -499,25 +659,42 @@ static curl_version_info_data version_info = {
   NULL, /* Hyper version */
   NULL  /* gsasl version */
 };
+#endif
 
 curl_version_info_data *curl_version_info(CURLversion stamp)
 {
 #if defined(USE_SSH)
+#ifdef __VSF__
+#   define ssh_buffer               (curl_version_ctx->curl_version_info.ssh_buffer)
+#else
   static char ssh_buffer[80];
 #endif
+#endif
 #ifdef USE_SSL
+#ifdef __VSF__
+#   define ssl_buffer               (curl_version_ctx->curl_version_info.ssl_buffer)
+#else
 #ifdef CURL_WITH_MULTI_SSL
   static char ssl_buffer[200];
 #else
   static char ssl_buffer[80];
 #endif
 #endif
+#endif
 #ifdef HAVE_BROTLI
+#ifdef __VSF__
+#   define brotli_buffer            (curl_version_ctx->curl_version_info.brotli_buffer)
+#else
   static char brotli_buffer[80];
 #endif
+#endif
 #ifdef HAVE_ZSTD
+#ifdef __VSF__
+#   define zstd_buffer              (curl_version_ctx->curl_version_info.zstd_buffer)
+#else
   static char zstd_buffer[80];
 #endif
+#endif
 
 #ifdef USE_SSL
   Curl_ssl_version(ssl_buffer, sizeof(ssl_buffer));
@@ -609,4 +786,18 @@ curl_version_info_data *curl_version_info(CURLversion stamp)
 
   (void)stamp; /* avoid compiler warnings, we don't use this */
   return &version_info;
+#ifdef __VSF__
+#ifdef USE_SSH
+#   undef ssh_buffer
+#endif
+#ifdef USE_SSL
+#   undef ssl_buffer
+#endif
+#ifdef HAVE_BROTLI
+#   undef brotli_buffer
+#endif
+#ifdef HAVE_ZSTD
+#   undef zstd_buffer
+#endif
+#endif
 }
diff --git a/lib/vtls/keylog.c b/lib/vtls/keylog.c
index a45945f8f..a078d4766 100644
--- a/lib/vtls/keylog.c
+++ b/lib/vtls/keylog.c
@@ -27,6 +27,14 @@
 #include "curl_memory.h"
 #include "memdebug.h"
 
+#ifdef __VSF__
+struct __curl_keylog_ctx {
+    FILE *keylog_file_fp;
+};
+define_vsf_curl_mod(curl_keylog, sizeof(struct __curl_keylog_ctx), VSF_CURL_MOD_KEYLOG, NULL)
+#   define curl_keylog_ctx      ((struct __curl_keylog_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_keylog)))
+#endif
+
 #define KEYLOG_LABEL_MAXLEN (sizeof("CLIENT_HANDSHAKE_TRAFFIC_SECRET") - 1)
 
 #define CLIENT_RANDOM_SIZE  32
@@ -40,7 +48,11 @@
 
 
 /* The fp for the open SSLKEYLOGFILE, or NULL if not open */
+#ifdef __VSF__
+#   define keylog_file_fp           (curl_keylog_ctx->keylog_file_fp)
+#else
 static FILE *keylog_file_fp;
+#endif
 
 void
 Curl_tls_keylog_open(void)
diff --git a/lib/vtls/mbedtls.c b/lib/vtls/mbedtls.c
index 1d209b273..7688a585c 100644
--- a/lib/vtls/mbedtls.c
+++ b/lib/vtls/mbedtls.c
@@ -73,6 +73,15 @@
 #include "curl_memory.h"
 #include "memdebug.h"
 
+#ifdef __VSF__
+struct __curl_mbedtls_ctx {
+    mbedtls_entropy_context ts_entropy;
+    int entropy_init_initialized;
+};
+define_vsf_curl_mod(curl_mbedtls, sizeof(struct __curl_mbedtls_ctx), VSF_CURL_MOD_MBEDTLS, NULL)
+#   define curl_mbedtls_ctx     ((struct __curl_mbedtls_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_mbedtls)))
+#endif
+
 struct ssl_backend_data {
   mbedtls_ctr_drbg_context ctr_drbg;
   mbedtls_entropy_context entropy;
@@ -96,9 +105,14 @@ struct ssl_backend_data {
 #endif
 
 #if defined(THREADING_SUPPORT)
+#ifdef __VSF__
+#   define ts_entropy               (curl_mbedtls_ctx->ts_entropy)
+#   define entropy_init_initialized (curl_mbedtls_ctx->entropy_init_initialized)
+#else
 static mbedtls_entropy_context ts_entropy;
 
 static int entropy_init_initialized = 0;
+#endif
 
 /* start of entropy_init_mutex() */
 static void entropy_init_mutex(mbedtls_entropy_context *ctx)
diff --git a/lib/vtls/mbedtls_threadlock.c b/lib/vtls/mbedtls_threadlock.c
index 751755c23..80a37f2e7 100644
--- a/lib/vtls/mbedtls_threadlock.c
+++ b/lib/vtls/mbedtls_threadlock.c
@@ -40,11 +40,23 @@
 /* The last #include file should be: */
 #include "memdebug.h"
 
+#ifdef __VSF__
+struct __curl_mbedtls_threadlock_ctx {
+    MBEDTLS_MUTEX_T *mutex_buf;
+};
+define_vsf_curl_mod(curl_mbedtls_threadlock, sizeof(struct __curl_mbedtls_threadlock_ctx), VSF_CURL_MOD_MBEDTLS_THREADLOCK, NULL)
+#   define curl_mbedtls_threadlock_ctx  ((struct __curl_mbedtls_threadlock_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_mbedtls_threadlock)))
+#endif
+
 /* number of thread locks */
 #define NUMT                    2
 
 /* This array will store all of the mutexes available to Mbedtls. */
+#ifdef __VSF__
+#   define mutex_buf                (curl_mbedtls_threadlock_ctx->mutex_buf)
+#else
 static MBEDTLS_MUTEX_T *mutex_buf = NULL;
+#endif
 
 int Curl_mbedtlsthreadlock_thread_setup(void)
 {
diff --git a/lib/vtls/vtls.c b/lib/vtls/vtls.c
index 6007bbba0..57a87ce6e 100644
--- a/lib/vtls/vtls.c
+++ b/lib/vtls/vtls.c
@@ -69,6 +69,19 @@
 #include "curl_memory.h"
 #include "memdebug.h"
 
+#ifdef __VSF__
+struct __curl_vtls_ctx {
+    bool init_ssl;
+    struct {
+        const struct Curl_ssl *selected;
+        char backends[200];
+        size_t backends_len;
+    } multissl_version;
+};
+define_vsf_curl_mod(curl_vtls, sizeof(struct __curl_vtls_ctx), VSF_CURL_MOD_VTLS, NULL)
+#   define curl_vtls_ctx  ((struct __curl_vtls_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_vtls)))
+#endif
+
 /* convenience macro to check if this handle is using a shared SSL session */
 #define SSLSESSION_SHARED(data) (data->share &&                        \
                                  (data->share->specifier &             \
@@ -224,7 +237,11 @@ int Curl_ssl_backend(void)
 #ifdef USE_SSL
 
 /* "global" init done? */
+#ifdef __VSF__
+#   define init_ssl                 (curl_vtls_ctx->init_ssl)
+#else
 static bool init_ssl = FALSE;
+#endif
 
 /**
  * Global SSL init
@@ -1343,9 +1360,15 @@ static const struct Curl_ssl *available_backends[] = {
 
 static size_t multissl_version(char *buffer, size_t size)
 {
+#ifdef __VSF__
+#   define selected                 (curl_vtls_ctx->multissl_version.selected)
+#   define backends                 (curl_vtls_ctx->multissl_version.backends)
+#   define backends_len             (curl_vtls_ctx->multissl_version.backends_len)
+#else
   static const struct Curl_ssl *selected;
   static char backends[200];
   static size_t backends_len;
+#endif
   const struct Curl_ssl *current;
 
   current = Curl_ssl == &Curl_ssl_multi ? available_backends[0] : Curl_ssl;
@@ -1383,6 +1406,11 @@ static size_t multissl_version(char *buffer, size_t size)
 
   strcpy(buffer, backends);
   return backends_len;
+#ifdef __VSF__
+#   undef selected
+#   undef backends
+#   undef backends_len
+#endif
 }
 
 static int multissl_setup(const struct Curl_ssl *backend)
diff --git a/src/tool_cb_dbg.c b/src/tool_cb_dbg.c
index 6e82e3852..93839b559 100644
--- a/src/tool_cb_dbg.c
+++ b/src/tool_cb_dbg.c
@@ -33,6 +33,19 @@
 
 #include "memdebug.h" /* keep this as LAST include */
 
+#ifdef __VSF__
+struct __curl_tool_cb_dbg_ctx {
+    struct {
+        time_t epoch_offset;
+        int known_offset;
+        bool newl;
+        bool traced_data;
+    } tool_debug_cb;
+};
+define_vsf_curl_mod(curl_tool_cb_dbg, sizeof(struct __curl_tool_cb_dbg_ctx), VSF_CURL_MOD_TOOL_CB_DBG, NULL)
+#   define curl_tool_cb_dbg_ctx     ((struct __curl_tool_cb_dbg_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_tool_cb_dbg)))
+#endif
+
 static void dump(const char *timebuf, const char *text,
                  FILE *stream, const unsigned char *ptr, size_t size,
                  trace tracetype, curl_infotype infotype);
@@ -57,8 +70,13 @@ int tool_debug_cb(CURL *handle, curl_infotype type,
 
   if(config->tracetime) {
     struct tm *now;
+#ifdef __VSF__
+#   define epoch_offset             (curl_tool_cb_dbg_ctx->tool_debug_cb.epoch_offset)
+#   define known_offset             (curl_tool_cb_dbg_ctx->tool_debug_cb.known_offset)
+#else
     static time_t epoch_offset;
     static int    known_offset;
+#endif
     tv = tvnow();
     if(!known_offset) {
       epoch_offset = time(NULL) - tv.tv_sec;
@@ -69,6 +87,10 @@ int tool_debug_cb(CURL *handle, curl_infotype type,
     now = localtime(&secs);  /* not thread safe but we don't care */
     msnprintf(timebuf, sizeof(timebuf), "%02d:%02d:%02d.%06ld ",
               now->tm_hour, now->tm_min, now->tm_sec, (long)tv.tv_usec);
+#ifdef __VSF__
+#   undef epoch_offset
+#   undef known_offset
+#endif
   }
   else
     timebuf[0] = 0;
@@ -102,8 +124,13 @@ int tool_debug_cb(CURL *handle, curl_infotype type,
     static const char * const s_infotype[] = {
       "*", "<", ">", "{", "}", "{", "}"
     };
+#ifdef __VSF__
+#   define newl                     (curl_tool_cb_dbg_ctx->tool_debug_cb.newl)
+#   define traced_data              (curl_tool_cb_dbg_ctx->tool_debug_cb.traced_data)
+#else
     static bool newl = FALSE;
     static bool traced_data = FALSE;
+#endif
 
     switch(type) {
     case CURLINFO_HEADER_OUT:
@@ -160,6 +187,10 @@ int tool_debug_cb(CURL *handle, curl_infotype type,
     }
 
     return 0;
+#ifdef __VSF__
+#   undef newl
+#   undef traced_data
+#endif
   }
 
 #ifdef CURL_DOES_CONVERSIONS
diff --git a/src/tool_convert.c b/src/tool_convert.c
index 04818e9a6..95def3b54 100644
--- a/src/tool_convert.c
+++ b/src/tool_convert.c
@@ -31,11 +31,31 @@
 
 #include "memdebug.h" /* keep this as LAST include */
 
+#ifdef __VSF__
+struct __curl_tool_convert_ctx {
+    iconv_t inbound_cd;     // = (iconv_t)-1;
+    iconv_t outbound_cd;    // = (iconv_t)-1;
+};
+static void __curl_tool_convert_mod_init(void *ctx)
+{
+    struct __curl_tool_convert_ctx *__tool_convert_ctx = ctx;
+    __tool_convert_ctx->inbound_cd = (iconv_t)-1;
+    __tool_convert_ctx->outbound_cd = (iconv_t)-1;
+}
+define_vsf_curl_mod(curl_tool_convert, sizeof(struct __curl_tool_convert_ctx), VSF_CURL_MOD_TOOL_CONVERT, __curl_tool_convert_mod_init)
+#   define curl_tool_convert_ctx    ((struct __curl_tool_convert_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_tool_convert)))
+#endif
+
 #ifdef HAVE_ICONV
 
 /* curl tool iconv conversion descriptors */
+#ifdef __VSF__
+#   define inbound_cd               (curl_ctx->tool_convert.inbound_cd)
+#   define outbound_cd              (curl_ctx->tool_convert.outbound_cd)
+#else
 static iconv_t inbound_cd  = (iconv_t)-1;
 static iconv_t outbound_cd = (iconv_t)-1;
+#endif
 
 /* set default codesets for iconv */
 #ifndef CURL_ICONV_CODESET_OF_NETWORK
diff --git a/src/tool_getpass.c b/src/tool_getpass.c
index 4c50a12d9..249447125 100644
--- a/src/tool_getpass.c
+++ b/src/tool_getpass.c
@@ -63,6 +63,27 @@
 
 #include "memdebug.h" /* keep this as LAST include */
 
+#ifdef __VSF__
+struct __curl_tool_getpass_ctx {
+#ifdef HAVE_TERMIOS_H
+#  define struct_term  struct termios
+#elif defined(HAVE_TERMIO_H)
+#  define struct_term  struct termio
+#else
+#  undef  struct_term
+#endif
+#ifdef struct_term
+    struct {
+        struct_term withecho;
+        struct_term noecho;
+    } ttyecho;
+#undef struct_term
+#endif
+};
+define_vsf_curl_mod(curl_tool_getpass, sizeof(struct __curl_tool_getpass_ctx), VSF_CURL_MOD_TOOL_GETPASS, NULL)
+#   define curl_tool_getpass_ctx    ((struct __curl_tool_getpass_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_tool_getpass)))
+#endif
+
 #ifdef __VMS
 /* VMS implementation */
 char *getpass_r(const char *prompt, char *buffer, size_t buflen)
@@ -182,8 +203,13 @@ char *getpass_r(const char *prompt, char *buffer, size_t buflen)
 static bool ttyecho(bool enable, int fd)
 {
 #ifdef struct_term
+#ifdef __VSF__
+#   define withecho                 (curl_tool_getpass_ctx->ttyecho.withecho)
+#   define noecho                   (curl_tool_getpass_ctx->ttyecho.noecho)
+#else
   static struct_term withecho;
   static struct_term noecho;
+#endif
 #endif
   if(!enable) {
     /* disable echo by extracting the current 'withecho' mode and remove the
@@ -215,6 +241,12 @@ static bool ttyecho(bool enable, int fd)
   return FALSE; /* not enabled */
 #endif
   return TRUE; /* enabled */
+#ifdef struct_term
+#ifdef __VSF__
+#   undef withecho
+#   undef noecho
+#endif
+#endif
 }
 
 char *getpass_r(const char *prompt, /* prompt to display */
diff --git a/src/tool_operate.c b/src/tool_operate.c
index fe2c43b55..5f4b76b0b 100644
--- a/src/tool_operate.c
+++ b/src/tool_operate.c
@@ -85,6 +85,10 @@
 
 #include "memdebug.h" /* keep this as LAST include */
 
+#ifdef __VSF__
+define_vsf_curl_mod(curl_tool_operate, sizeof(struct __curl_tool_operate_ctx), VSF_CURL_MOD_TOOL_OPERATE, NULL)
+#endif
+
 #ifdef CURLDEBUG
 /* libcurl's debug builds provide an extra function */
 CURLcode curl_easy_perform_ev(CURL *easy);
@@ -203,8 +207,12 @@ static curl_off_t VmsSpecialSize(const char *name,
 
 #define BUFFER_SIZE (100*1024)
 
+#ifdef __VSF__
+#   define transfersl               (curl_tool_operate_ctx->transfersl)
+#else
 struct per_transfer *transfers; /* first node */
 static struct per_transfer *transfersl; /* last node */
+#endif
 
 /* add_per_transfer creates a new 'per_transfer' node in the linked
    list of transfers */
@@ -735,7 +743,11 @@ static CURLcode single_transfer(struct GlobalConfig *global,
   }
 
   while(config->state.urlnode) {
+#ifdef __VSF__
+#   define warn_more_options        (curl_tool_operate_ctx->single_transfer.warn_more_options)
+#else
     static bool warn_more_options = FALSE;
+#endif
     char *infiles; /* might be a glob pattern */
     struct URLGlob *inglob = state->inglob;
     urlnode = config->state.urlnode;
@@ -2145,6 +2157,9 @@ static CURLcode single_transfer(struct GlobalConfig *global,
       }
     }
     break;
+#ifdef __VSF__
+#   undef warn_more_options
+#endif
   }
 
   if(!*added || result) {
@@ -2154,7 +2169,11 @@ static CURLcode single_transfer(struct GlobalConfig *global,
   return result;
 }
 
+#ifdef __VSF__
+#   define all_added                (curl_tool_operate_ctx->all_added)
+#else
 static long all_added; /* number of easy handles currently added */
+#endif
 
 /*
  * add_parallel_transfers() sets 'morep' to TRUE if there are more transfers
diff --git a/src/tool_operate.h b/src/tool_operate.h
index 61994052f..e2b5702b1 100644
--- a/src/tool_operate.h
+++ b/src/tool_operate.h
@@ -76,6 +76,20 @@ struct per_transfer {
 
 CURLcode operate(struct GlobalConfig *config, int argc, argv_item_t argv[]);
 
+#ifdef __VSF__
+struct __curl_tool_operate_ctx {
+    struct per_transfer *transfers;
+    struct per_transfer *transfersl;
+    long all_added;
+    struct {
+        bool warn_more_options;
+    } single_transfer;
+};
+declare_vsf_curl_mod(curl_tool_operate)
+#   define curl_tool_operate_ctx    ((struct __curl_tool_operate_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_tool_operate)))
+#   define transfers                (curl_tool_operate_ctx->transfers)
+#else
 extern struct per_transfer *transfers; /* first node */
+#endif
 
 #endif /* HEADER_CURL_TOOL_OPERATE_H */
diff --git a/src/tool_paramhlp.c b/src/tool_paramhlp.c
index 8ac6cf53e..901cdc2e3 100644
--- a/src/tool_paramhlp.c
+++ b/src/tool_paramhlp.c
@@ -37,12 +37,26 @@
 
 #include "memdebug.h" /* keep this as LAST include */
 
+#ifdef __VSF__
+struct __curl_tool_paramhlp_ctx {
+    struct {
+        int outnum;
+    } new_getout;
+};
+define_vsf_curl_mod(curl_tool_paramhlp, sizeof(struct __curl_tool_paramhlp_ctx), VSF_CURL_MOD_TOOL_PARAMHLP, NULL)
+#   define curl_tool_paramhlp_ctx   ((struct __curl_tool_paramhlp_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_tool_paramhlp)))
+#endif
+
 struct getout *new_getout(struct OperationConfig *config)
 {
   struct getout *node = calloc(1, sizeof(struct getout));
   struct getout *last = config->url_last;
   if(node) {
+#ifdef __VSF__
+#   define outnum                   (curl_tool_paramhlp_ctx->new_getout.outnum)
+#else
     static int outnum = 0;
+#endif
 
     /* append this new node last in the list */
     if(last)
@@ -55,6 +69,9 @@ struct getout *new_getout(struct OperationConfig *config)
 
     node->flags = config->default_node_flags;
     node->num = outnum++;
+#ifdef __VSF__
+#   undef outnum
+#endif
   }
   return node;
 }
diff --git a/src/tool_progress.c b/src/tool_progress.c
index 031f8b8d4..522eefda2 100644
--- a/src/tool_progress.c
+++ b/src/tool_progress.c
@@ -28,6 +28,10 @@
 /* use our own printf() functions */
 #include "curlx.h"
 
+#ifdef __VSF__
+define_vsf_curl_mod(curl_tool_progress, sizeof(struct __curl_tool_progress_ctx), VSF_CURL_MOD_TOOL_PROGRESS, NULL)
+#endif
+
 /* The point of this function would be to return a string of the input data,
    but never longer than 5 columns (+ one zero byte).
    Add suffix k, M, G when suitable... */
@@ -141,6 +145,15 @@ static void time2str(char *r, curl_off_t seconds)
   }
 }
 
+#ifdef __VSF__
+#   define all_dltotal              (curl_tool_progress_ctx->all_dltotal)
+#   define all_ultotal              (curl_tool_progress_ctx->all_ultotal)
+#   define all_dlalready            (curl_tool_progress_ctx->all_dlalready)
+#   define all_ulalready            (curl_tool_progress_ctx->all_ulalready)
+#   define speedindex               (curl_tool_progress_ctx->speedindex)
+#   define indexwrapped             (curl_tool_progress_ctx->indexwrapped)
+#   define speedstore               (curl_tool_progress_ctx->speedstore)
+#else
 static curl_off_t all_dltotal = 0;
 static curl_off_t all_ultotal = 0;
 static curl_off_t all_dlalready = 0;
@@ -157,6 +170,7 @@ struct speedcount {
 static unsigned int speedindex;
 static bool indexwrapped;
 static struct speedcount speedstore[SPEEDCNT];
+#endif
 
 /*
   |DL% UL%  Dled  Uled  Xfers  Live   Qd Total     Current  Left    Speed
@@ -166,8 +180,13 @@ bool progress_meter(struct GlobalConfig *global,
                     struct timeval *start,
                     bool final)
 {
-  static struct timeval stamp;
+#ifdef __VSF__
+#   define __stamp                  (curl_tool_progress_ctx->progress_meter.stamp)
+#   define header                   (curl_tool_progress_ctx->progress_meter.header)
+#else
+  static struct timeval __stamp;
   static bool header = FALSE;
+#endif
   struct timeval now;
   long diff;
 
@@ -175,7 +194,7 @@ bool progress_meter(struct GlobalConfig *global,
     return FALSE;
 
   now = tvnow();
-  diff = tvdiff(now, stamp);
+  diff = tvdiff(now, __stamp);
 
   if(!header) {
     header = TRUE;
@@ -200,7 +219,7 @@ bool progress_meter(struct GlobalConfig *global,
     curl_off_t all_queued = 0;  /* pending */
     curl_off_t speed = 0;
     unsigned int i;
-    stamp = now;
+    __stamp = now;
 
     /* first add the amounts of the already completed transfers */
     all_dlnow += all_dlalready;
@@ -314,6 +333,10 @@ bool progress_meter(struct GlobalConfig *global,
     return TRUE;
   }
   return FALSE;
+#ifdef __VSF__
+#   undef __stamp
+#   undef header
+#endif
 }
 
 void progress_finalize(struct per_transfer *per)
diff --git a/src/tool_progress.h b/src/tool_progress.h
index da9bdedd2..1f0472738 100644
--- a/src/tool_progress.h
+++ b/src/tool_progress.h
@@ -34,6 +34,34 @@ bool progress_meter(struct GlobalConfig *global,
                     bool final);
 void progress_finalize(struct per_transfer *per);
 
+#ifdef __VSF__
+struct speedcount {
+  curl_off_t dl;
+  curl_off_t ul;
+  struct timeval stamp;
+};
+struct __curl_tool_progress_ctx {
+    curl_off_t all_dltotal;
+    curl_off_t all_ultotal;
+    curl_off_t all_dlalready;
+    curl_off_t all_ulalready;
+    curl_off_t all_xfers;
+
+#define SPEEDCNT 10
+    unsigned int speedindex;
+    bool indexwrapped;
+    struct speedcount speedstore[SPEEDCNT];
+
+    struct {
+        struct timeval stamp;
+        bool header;
+    } progress_meter;
+};
+declare_vsf_curl_mod(curl_tool_progress)
+#   define curl_tool_progress_ctx   ((struct __curl_tool_progress_ctx *)vsf_linux_dynlib_ctx(&vsf_curl_mod_name(curl_tool_progress)))
+#   define all_xfers                (curl_tool_progress_ctx->all_xfers)
+#else
 extern curl_off_t all_xfers;   /* total number */
+#endif
 
 #endif /* HEADER_CURL_TOOL_PROGRESS_H */
